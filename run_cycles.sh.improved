#!/bin/bash

# Smart script that waits for each cycle to FULLY complete before starting the next
# IMPROVED VERSION: Uses environment variables for better configuration

# Configuration - can be overridden by environment variables
USER_ID="${USER_ID:-6440da7fe6304b2f884ea8721cc9a9c0}"  # Default user ID, override with env var
INTERVAL_MINUTES="${INTERVAL_MINUTES:-30}"  # Wait X minutes AFTER cycle completes
BACKEND_URL="${BACKEND_URL:-http://localhost:8000}"  # Backend API URL
LOG_FILE="${LOG_FILE:-logs/automatic_scheduling.log}"  # Log file path

echo "======================================"
echo "Smart Sequential Cycle Runner"
echo "User: $USER_ID"
echo "Interval: $INTERVAL_MINUTES min (after completion)"
echo "Backend URL: $BACKEND_URL"
echo "Log File: $LOG_FILE"
echo "======================================"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

# Function to wait for cycle completion
wait_for_cycle_completion() {
    local CYCLE_START_TS=$1
    local MAX_WAIT_HOURS=6  # Maximum wait time (6 hours)
    local MAX_WAIT_SECONDS=$((MAX_WAIT_HOURS * 3600))
    
    echo "  ‚è≥ Waiting for cycle to complete (max ${MAX_WAIT_HOURS}h)..."
    
    # Poll every 30 seconds, checking if cycle has ended
    local ITERATION=0
    while true; do
        sleep 30
        ITERATION=$((ITERATION + 1))
        CURRENT_TS=$(date +%s)
        ELAPSED=$((CURRENT_TS - CYCLE_START_TS))
        
        # Check for timeout
        if [ $ELAPSED -gt $MAX_WAIT_SECONDS ]; then
            echo "  ‚ö†Ô∏è  Cycle exceeded maximum wait time (${MAX_WAIT_HOURS}h), assuming stuck. Moving on..."
            break
        fi
        
        # Check for cycle completion - use larger tail to catch completion even if logs are buffered
        # USER_ID in logs has dashes, but script variable doesn't - match both formats
        USER_ID_WITH_DASHES=$(echo "$USER_ID" | sed 's/\([0-9a-f]\{8\}\)\([0-9a-f]\{4\}\)\([0-9a-f]\{4\}\)\([0-9a-f]\{4\}\)\([0-9a-f]\{12\}\)/\1-\2-\3-\4-\5/')
        LAST_LOG=$(tail -n 100 "$LOG_FILE" 2>/dev/null | grep -E "\[CYCLE (END|SUMMARY)\]" | grep -E "$USER_ID|$USER_ID_WITH_DASHES" | tail -n 1)
        
        if [ ! -z "$LAST_LOG" ]; then
            CYCLE_END_TIME=$(echo "$LAST_LOG" | grep -oP '\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}' | head -n 1)
            
            if [ ! -z "$CYCLE_END_TIME" ]; then
                LOG_TIMESTAMP=$(date -d "$CYCLE_END_TIME" +%s 2>/dev/null)
                
                if [ ! -z "$LOG_TIMESTAMP" ] && [ "$LOG_TIMESTAMP" -gt "$CYCLE_START_TS" ]; then
                    echo "  ‚úÖ Cycle completed at $CYCLE_END_TIME"
                    break
                fi
            fi
        fi
        
        # Log progress every 10 minutes
        if [ $((ITERATION % 20)) -eq 0 ]; then
            echo "  ‚è≥ Still waiting... (${ELAPSED}s elapsed, ~$((ELAPSED / 60)) minutes)"
        fi
    done
}

# Main loop
while true; do
    CYCLE_START=$(date '+%Y-%m-%d %H:%M:%S')
    CYCLE_START_TIMESTAMP=$(date +%s)
    
    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "[$CYCLE_START] Starting new cycle..."
    
    # Check if backend is accessible
    if ! curl -s -f "${BACKEND_URL}/health" > /dev/null 2>&1; then
        echo "  ‚ùå Backend not accessible at ${BACKEND_URL}/health"
        echo "  ‚è∏Ô∏è  Waiting 5 minutes before retry..."
        sleep 300
        continue
    fi
    
    # Trigger the cycle
    RESPONSE=$(curl -s -X POST "${BACKEND_URL}/agent/test-cycle-no-auth?test_user_id=$USER_ID" \
                    -H "Content-Type: application/json")
    
    STATUS=$(echo "$RESPONSE" | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
    
    if [ "$STATUS" = "success" ]; then
        echo "  ‚úÖ Cycle triggered successfully"
        
        # Wait for it to complete (pass cycle start timestamp)
        wait_for_cycle_completion $CYCLE_START_TIMESTAMP
        
        ACTUAL_END=$(date '+%Y-%m-%d %H:%M:%S')
        DURATION=$(($(date +%s) - CYCLE_START_TIMESTAMP))
        echo "  üìä Total duration: $((DURATION / 60)) minutes $((DURATION % 60)) seconds"
        
        # Wait interval before next cycle
        echo "  ‚è∏Ô∏è  Waiting $INTERVAL_MINUTES minutes before next cycle..."
        sleep $((INTERVAL_MINUTES * 60))
    else
        echo "  ‚ùå Failed to trigger cycle: $RESPONSE"
        echo "  ‚è∏Ô∏è  Waiting 5 minutes before retry..."
        sleep 300
    fi
done

